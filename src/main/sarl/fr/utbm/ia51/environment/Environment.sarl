/** 
 * 
 */
package fr.utbm.ia51.environment

import fr.utbm.ia51.agents.Person
import fr.utbm.ia51.graph.human.GraphHuman
import fr.utbm.ia51.tools.Point2f
import fr.utbm.ia51.tools.Vector2f
import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Schedules
import java.util.LinkedList
import java.util.UUID

agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules
		
	// the time/date of the app
	var time = 0
	
	var loop_duration : int = 100
	
	var personIdList = <UUID>newLinkedList
	var influenceList = <Influence>newLinkedList
	
	
	var listGraphHumans = <GraphHuman>newLinkedList
	var graphHumans  = <UUID,GraphHuman>newHashMap
	

	var numberOfPersonToSpawn = 2
	var numberOfInfluencesGot = 0
	var numberOfInfluencesToGet = 0
	
	on Initialize {	
		synchronized (this) {
			// Event trigger before the agent begin to live or to be used.
			// You should put all the initialization statements in this block of code.
			this.loop_duration = occurrence.parameters.get(0) as Integer
			this.listGraphHumans = occurrence.parameters.get(1) as LinkedList<GraphHuman>
			
			
			
			
			
			loggingName = "Environment"
			info("The environment was started.")
			var i= 0
			for (g : listGraphHumans) {
				this.graphHumans.put(g.uuid, g)
				spawnAPerson("Person"+i,g)
				
			}
			emit(new RunBeginingOfStep)
		}
	}

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on Influence {
		synchronized (this) {
			info("Got an influence")
			// this.actions += new MazeChangeQuery(occurrence.source.UUID, occurrence.direction)
			influenceList.add(occurrence)
			numberOfInfluencesGot++
			if (numberOfInfluencesGot > numberOfInfluencesToGet-1) {
				info("Got all the influences")
				numberOfInfluencesGot = 0
				emit(new RunEndOfStep) // [it == defaultAddress]
			}
		}
	}

	on RunEndOfStep {
		synchronized (this) {
			info("The step ends")
			applyInfluences(influenceList)
			/*
			// Endogenous behavior: move the pacman from the player's action
			var avatarDirection = this.player.direction
			var avatarAction = new MazeChangeQuery(this.player.bodyId, avatarDirection)
			this.actions += avatarAction

			// Endogenous behavior: decrease the super power of Pacman
			getSuperPowerAccessor(this.player.bodyId).decreaseSuperPower

			// Change the state of the universe
			if (applyActions(this.actions)) {
				// Pacman is dead.
				emit(new PacManIsDead)
				fireGameOver
				killMe
			}

			// Increase time
			this.time++

			// Notify about environment's changes
			fireEnvironmentChange
			*/
			// Move to next step
			
			time++
			emit(new RunBeginingOfStep)
		}
	}

	on RunBeginingOfStep {
		synchronized (this) {
			info("The step begins")
			/*this.actions.clear

			for (e : getPerceptions().entrySet) {
				sendPerception(this.time, e.key.agentId, e.value, e.key.position)
			}*/
			influenceList.clear()

			var position : Point2f = new Point2f
			var orientation : Vector2f = new Vector2f
			var linearSpeed : float = 0f
			var maxLinear : float = 0f
			var angularSpeed : float = 0f
			var maxAngular : float = 0f
			var perceivedObjects = <Point2f>newArrayList
			
			info("Sending a perception")
			emit(
				new Perception(position, orientation, linearSpeed, maxLinear, angularSpeed, maxAngular,
					perceivedObjects))
		}
	}
	
	def spawnAPerson(name: String, graphHuman : GraphHuman) {
		
		var id = spawnInContextWithID(typeof(Person),graphHuman.uuid,defaultContext,name,graphHuman.x,graphHuman.y)
		info(name + " spawned")
		numberOfInfluencesToGet++
		personIdList.add(id)
	}
	
	def applyInfluences(influenceList: LinkedList<Influence>) {
		
		
		for (var i = 0; i < influenceList.size; i++) {
			Thread::sleep(loop_duration)
			var influence = influenceList.get(i)
			
			var newPosX : double = influence.wantedPosX
			var newPosY : double = influence.wantedPosY
			this.graphHumans.get(influence.caller.ID).moveTo(newPosX,newPosY,2)
			
			emit(new ActionToPerson(newPosX, newPosY), [it.UUID == influence.caller.ID])
			// influence.caller.posX
		}
	}

}
