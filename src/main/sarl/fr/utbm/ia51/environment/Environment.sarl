/** 
 * 
 */
package fr.utbm.ia51.environment

import fr.utbm.ia51.Globals
import fr.utbm.ia51.activities.ActivityType
import fr.utbm.ia51.agents.Person
import fr.utbm.ia51.graph.environment.GraphEnvironment
import fr.utbm.ia51.graph.human.GraphHuman
import fr.utbm.ia51.tools.Point2f
import fr.utbm.ia51.tools.Vector2f
import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Schedules
import java.util.ArrayList
import java.util.LinkedList
import java.util.UUID
import javafx.^event.ActionEvent
import javafx.scene.control.Button

agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules
		
	// the time/date of the app
	var time = 0
	
	var personIdList = <UUID>newLinkedList
	var influenceList = <Influence>newLinkedList
	
	
	var listGraphHumans = <GraphHuman>newLinkedList
	var graphHumans  = <UUID, PersonContainer>newHashMap
	var ringButton : Button 
	

	var numberOfPersonToSpawn = 2
	var numberOfInfluencesGot = 0
	var numberOfInfluencesToGet = 0
	
	
	
	var bellRings = false
	
	on Initialize {	
		synchronized (this) {
			// Event trigger before the agent begin to live or to be used.
			// You should put all the initialization statements in this block of code.
			this.listGraphHumans = occurrence.parameters.get(0) as LinkedList<GraphHuman>
			ringButton = this.listGraphHumans.first.graphEnvironment.ringButton
			
			ringButton.onAction = [e : ActionEvent| this.bellRings = true]
			
			loggingName = "Environment"
			info("The environment was started.")
			var i= 0
			for (g : listGraphHumans) {
				var personContainer = new PersonContainer(g, ActivityType.TOILET, new Vector2f(), g)
				this.graphHumans.put(g.uuid, personContainer)
				spawnAPerson("Person"+i,g,g.environment)
				i++
				
			}
			emit(new RunBeginingOfStep)
		}
	}

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on Influence {
		synchronized (this) {
			//info("Got an influence")
			// this.actions += new MazeChangeQuery(occurrence.source.UUID, occurrence.direction)
			influenceList.add(occurrence)
			numberOfInfluencesGot++
			if (numberOfInfluencesGot > numberOfInfluencesToGet-1) {
				//info("Got all the influences")
				numberOfInfluencesGot = 0
				emit(new RunEndOfStep) // [it == defaultAddress]
			}
		}
	}

	on RunEndOfStep {
		synchronized (this) {
			//info("The step ends")
			applyInfluences(influenceList)
			/*
			// Endogenous behavior: move the pacman from the player's action
			var avatarDirection = this.player.direction
			var avatarAction = new MazeChangeQuery(this.player.bodyId, avatarDirection)
			this.actions += avatarAction

			// Endogenous behavior: decrease the super power of Pacman
			getSuperPowerAccessor(this.player.bodyId).decreaseSuperPower

			// Change the state of the universe
			if (applyActions(this.actions)) {
				// Pacman is dead.
				emit(new PacManIsDead)
				fireGameOver
				killMe
			}

			// Increase time
			this.time++

			// Notify about environment's changes
			fireEnvironmentChange
			*/
			// Move to next step
			
			time++
			
			var sleepTime = Globals::LOOP_DURATION - Globals::chrono.getTime()
			if(sleepTime < 0) sleepTime = 0
			Thread::sleep(sleepTime) // We sleep before the next step
			
			if (Globals::SHUT_DOWN_SIGNAL) {
				emit(new ShutDown)
			} else {
				emit(new RunBeginingOfStep)
			}
		}
	}
	
	on ShutDown {
		killMe()
	}

	on RunBeginingOfStep {
		synchronized (this) {
			Globals::chrono.reset();
			//info("The step begins")
			/*this.actions.clear

			for (e : getPerceptions().entrySet) {
				sendPerception(this.time, e.key.agentId, e.value, e.key.position)
			}*/
			influenceList.clear()
			
			for (entry : graphHumans.entrySet) {
				var graphHuman = entry.value.graphHuman
				var activityType = entry.value.activityType
				var targetLinearMotion = new Vector2f()
				var uuid = entry.key
				
				var position : Point2f = new Point2f(graphHuman.x, graphHuman.y)
				//TODO
				var orientation : Vector2f = new Vector2f
				var linearSpeed : float = 0f
				var maxLinear : float = 3f
				var angularSpeed : float = 0f
				var maxAngular : float = 0f
				var perceivedObjects = <ActivityType, ArrayList<Point2f>>newHashMap
				var intersectedArtifacts = graphHuman.environment.getIntersectedArtifacts(graphHuman)
				
				// TODO get target, something like:
				var intersectedPeople = <GraphHuman>newArrayList
				// graphHuman.environment.getIntersectedHumans(graphHuman)
				if (activityType == ActivityType.FIGHT) {
					var fightTarget = entry.value.fightTarget
					// if the target has changed (default one is ourself
					if (fightTarget !== graphHuman) {
						var targetUUID = fightTarget.uuid
						targetLinearMotion = graphHumans.get(targetUUID).linearMotion
					}
				}
				
				for(intersectedArtifact : intersectedArtifacts) {
					var intersectedPoint = intersectedArtifact.getNearestPointInEntity(position)
					var centerPoint = intersectedArtifact.getCenterPoint()
					
					var points = <Point2f>newArrayList
					points.add(intersectedPoint)
					points.add(centerPoint)
					
					perceivedObjects.put(intersectedArtifact.activityType, points)
					
					// creating the list of intersected GraphHuman
					if(intersectedArtifact instanceof GraphHuman) {
						intersectedPeople.add(intersectedArtifact)
					}
				}
				
				// info("Sending a perception")
				emit(
					new Perception(position, orientation, linearSpeed, maxLinear, angularSpeed, maxAngular, this.bellRings,
						perceivedObjects, intersectedPeople, targetLinearMotion), [it.UUID == uuid])
			}
			this.bellRings = false
		}
	}
	
	on UpdatedActivity {

		synchronized(this){		
//		this.graphHumans.get(occurrence.callerID).graphHuman.activityDesired.visible=true
		this.graphHumans.get(occurrence.callerID).graphHuman.activity = occurrence.activity
		}
	}
	
	on UpdatedFightTarget {
		synchronized (this) {
			// TODO CHECK IF IT actually UPDATES IN HASHMAP
			this.graphHumans.get(occurrence.callerID).fightTarget = occurrence.fightTarget
		}
	}
	
	def spawnAPerson(name: String, graphHuman : GraphHuman, environment : GraphEnvironment) {
		
		var id = spawnInContextWithID(typeof(Person),graphHuman.uuid,defaultContext,name,graphHuman.x,graphHuman.y,environment)
		info(name + " spawned")
		numberOfInfluencesToGet++
		personIdList.add(id)
	}
	
	def applyInfluences(influenceList: LinkedList<Influence>) {
		for (var i = 0; i < influenceList.size; i++) {
			var influence = influenceList.get(i)
			
			var newPosition : Point2f = influence.position + influence.linear
			
			this.graphHumans.get(influence.callerID).graphHuman.moveTo(newPosition.x, newPosition.y, 2)
			if (Globals::SHOW_FORCE_VECTOR) {
				this.graphHumans.get(influence.callerID).graphHuman.showForce(influence.linear.x, influence.linear.y)
			}
			
			
			
			if (this.graphHumans.get(influence.callerID).graphHuman.environment.isInCoveredArea(newPosition))
				this.graphHumans.get(influence.callerID).graphHuman.sethideInCoveredArea(true)
			else
				this.graphHumans.get(influence.callerID).graphHuman.sethideInCoveredArea(false)
					
			emit(new ActionToPerson(newPosition.x, newPosition.y), [it.UUID == influence.callerID])
			// influence.caller.posX
		}
	}

}
