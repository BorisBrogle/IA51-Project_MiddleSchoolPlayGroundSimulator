/** 
 * 
 */
package fr.utbm.ia51.environment

import fr.utbm.ia51.Globals
import fr.utbm.ia51.agents.Person
import fr.utbm.ia51.graph.environment.GraphEnvironment
import fr.utbm.ia51.graph.human.GraphHuman
import fr.utbm.ia51.tools.Point2f
import fr.utbm.ia51.tools.Vector2f
import io.sarl.core.AgentKilled
import io.sarl.core.AgentSpawned
import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.MemberJoined
import io.sarl.core.MemberLeft
import io.sarl.core.Schedules
import java.util.LinkedList
import java.util.UUID

agent Environment {
	uses Logging, DefaultContextInteractions, Lifecycle, Schedules
		
	// the time/date of the app
	var time = 0
	
	var personIdList = <UUID>newLinkedList
	var influenceList = <Influence>newLinkedList
	
	
	var listGraphHumans = <GraphHuman>newLinkedList
	var graphHumans  = <UUID,GraphHuman>newHashMap
	

	var numberOfPersonToSpawn = 2
	var numberOfInfluencesGot = 0
	var numberOfInfluencesToGet = 0
	
	var hasRing = false
	
	on Initialize {	
		synchronized (this) {
			// Event trigger before the agent begin to live or to be used.
			// You should put all the initialization statements in this block of code.
			this.listGraphHumans = occurrence.parameters.get(0) as LinkedList<GraphHuman>
			
			
			
			
			
			loggingName = "Environment"
			info("The environment was started.")
			var i= 0
			for (g : listGraphHumans) {
				this.graphHumans.put(g.uuid, g)
				spawnAPerson("Person"+i,g,g.environment)
				i++
				
			}
			emit(new RunBeginingOfStep)
		}
	}

	on Destroy {
		// Event trigger when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
	}

	on AgentSpawned {
		// A new agent has been spawned in our context.
	}

	on AgentKilled {
		// A new agent has been killed in our context.
	}

	on ContextJoined {
		// Event trigger when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
	}

	on MemberJoined {
		// Event trigger when an agent joins one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on MemberLeft {
		// Event trigger when an agent leaves one of our shared super-holons.
		// Sent to all members of the considered super-holon.
	}

	on Influence {
		synchronized (this) {
			//info("Got an influence")
			// this.actions += new MazeChangeQuery(occurrence.source.UUID, occurrence.direction)
			influenceList.add(occurrence)
			numberOfInfluencesGot++
			if (numberOfInfluencesGot > numberOfInfluencesToGet-1) {
				//info("Got all the influences")
				numberOfInfluencesGot = 0
				emit(new RunEndOfStep) // [it == defaultAddress]
			}
		}
	}

	on RunEndOfStep {
		synchronized (this) {
			//info("The step ends")
			applyInfluences(influenceList)
			/*
			// Endogenous behavior: move the pacman from the player's action
			var avatarDirection = this.player.direction
			var avatarAction = new MazeChangeQuery(this.player.bodyId, avatarDirection)
			this.actions += avatarAction

			// Endogenous behavior: decrease the super power of Pacman
			getSuperPowerAccessor(this.player.bodyId).decreaseSuperPower

			// Change the state of the universe
			if (applyActions(this.actions)) {
				// Pacman is dead.
				emit(new PacManIsDead)
				fireGameOver
				killMe
			}

			// Increase time
			this.time++

			// Notify about environment's changes
			fireEnvironmentChange
			*/
			// Move to next step
			
			time++
			
			var sleepTime = Globals::LOOP_DURATION - Globals::chrono.getTime()
			if(sleepTime < 0) sleepTime = 0
			Thread::sleep(sleepTime) // We sleep before the next step
			
			emit(new RunBeginingOfStep)
		}
	}

	on RunBeginingOfStep {
		synchronized (this) {
			Globals::chrono.reset();
			//info("The step begins")
			/*this.actions.clear

			for (e : getPerceptions().entrySet) {
				sendPerception(this.time, e.key.agentId, e.value, e.key.position)
			}*/
			influenceList.clear()

			var position : Point2f = new Point2f
			var orientation : Vector2f = new Vector2f
			var linearSpeed : float = 0f
			var maxLinear : float = 1f
			var angularSpeed : float = 0f
			var maxAngular : float = 0f
			var perceivedObjects = <Point2f>newArrayList
			var bellRings : boolean = false

			// ringing the bell
			if(time > 1000 && !hasRing) {
				bellRings = true
				hasRing = true
			}
			
			//info("Sending a perception")
			// Faire une for each qui fait pour tous les graphHumans
			// .Get des artifacts autours 
			emit(
				new Perception(position, orientation, linearSpeed, maxLinear, angularSpeed, maxAngular, bellRings, perceivedObjects))

		}
	}
	
	def spawnAPerson(name: String, graphHuman : GraphHuman, environment : GraphEnvironment) {
		
		var id = spawnInContextWithID(typeof(Person),graphHuman.uuid,defaultContext,name,graphHuman.x,graphHuman.y,environment)
		info(name + " spawned")
		numberOfInfluencesToGet++
		personIdList.add(id)
	}
	
	def applyInfluences(influenceList: LinkedList<Influence>) {
		for (var i = 0; i < influenceList.size; i++) {
			var influence = influenceList.get(i)
			
			var newPosition : Point2f = influence.position + influence.linear
			
			this.graphHumans.get(influence.callerID).moveTo(newPosition.x, newPosition.y, 2)
			
			emit(new ActionToPerson(newPosition.x, newPosition.y), [it.UUID == influence.callerID])
			// influence.caller.posX
		}
	}

}
